package titleparser

import (
	"bufio"
	"bytes"
	"compress/gzip"
	"encoding/json"
	"fmt"
	"io"
	"io/ioutil"
	"log"
	"net/http"
	"strings"

	"github.com/kiteco/kiteco/kite-golib/awsutil"
	"github.com/kiteco/kiteco/kite-golib/fileutil"
)

// ruleType is a numerical representation of a rule type
type ruleType int

const (
	// emptyTitleRule checks wehther the title is empty.
	emptyTitleRule ruleType = 1 << iota

	// trailingPeriodRule checks whether the title has nay trailing periods.
	trailingPeriodRule

	// multipleSentencesRule checks whether the title contains multiple sentences.
	multipleSentencesRule

	// startWithVerbBaseRule checks whether the title starts with a verb base.
	startWithVerbBaseRule

	// hasApostrophesRule checks whether the title contains apostrophes.
	hasApostrophesRule

	// hasContractionsRule checks whether the title contains any contractions.
	hasContractionsRule

	// useOneNotAOrAnRule checks whether the title contains the word 'one'.
	useOneNotAOrAnRule

	// startWithReturnRule checks whether the title starts with the word 'return'.
	startWithReturnRule

	// hasUseToVBRule checks whether the title starts with the phrase 'use to...'.
	hasUseToVBRule

	// codeArgsNotInTitleRule checks whether there are any keyword args in the code not mentioned in the title.
	codeArgsNotInTitleRule

	// useShapeAsAdjRule checks whether the title uses 'shape' as an adj.
	useShapeAsAdjRule

	// hasSemanticCousinsRule checks whether the verb used in the title has any semantic cousins.
	hasSemanticCousinsRule

	// allRules represents all the rules.
	allRules = ruleType(^int(0))

	// default rule set
	defaultRuleSet = emptyTitleRule |
		trailingPeriodRule |
		multipleSentencesRule |
		hasApostrophesRule |
		hasContractionsRule |
		useOneNotAOrAnRule |
		startWithReturnRule |
		hasUseToVBRule |
		useShapeAsAdjRule |
		hasSemanticCousinsRule
)

var (
	ruleMap = map[ruleType]rule{
		emptyTitleRule:         emptyTitle,
		trailingPeriodRule:     trailingPeriod,
		multipleSentencesRule:  multipleSentences,
		startWithVerbBaseRule:  startWithVerbBase,
		hasApostrophesRule:     hasApostrophes,
		hasContractionsRule:    hasContractions,
		useOneNotAOrAnRule:     useOneNotAOrAn,
		startWithReturnRule:    startWithReturn,
		hasUseToVBRule:         hasUseToVB,
		codeArgsNotInTitleRule: codeArgsNotInTitle,
		useShapeAsAdjRule:      useShapeAsAdj,
	}
)

// rule is a function that implements any style rule.
type rule func(*parsedTitle) ([]*TitleViolation, error)

// parsedTitle wraps the data needed for running title linter.
type parsedTitle struct {
	parsableTitle string   // title without special characters that is fed into the parser
	cleanTitle    string   // title generated by the curator with back ticks removed
	parseTree     string   // parse tree of the parsableTitle
	code          string   // the code field of the code exmaple
	prelude       string   // the prelude field of the code example
	tags          []*token // tags in the parseTree
}

func newParsedTitle(parsableTitle, cleanTitle, parseTree, code, prelude string, tags []*token) *parsedTitle {
	return &parsedTitle{
		parsableTitle: parsableTitle,
		cleanTitle:    cleanTitle,
		parseTree:     parseTree,
		code:          code,
		prelude:       prelude,
		tags:          tags,
	}
}

// TitleViolation is a struct that contains the error message for a title style violation
type TitleViolation struct {
	Message string `json:"message"`
}

// TitleValidator is used to validate the title against a set of style rules.
type TitleValidator struct {
	word2vecMap  map[string][]float64 // a map that maps a word to its word2vec representation
	verbList     strList              // a list of verbs that we prefer to be used in titles
	parserClient *ParserClient        // a client that makes https queries to the parser server
	rules        []rule               // rules that the validator checks
}

// NewTitleValidator returns a new TitleValidator object.
func NewTitleValidator(word2vec, verbs, server string) (*TitleValidator, error) {
	if word2vec == "" {
		return nil, fmt.Errorf("cannot instantiate a title validator because no word2vec file is specified")
	}
	log.Println("Loading word2vec model")
	word2vecMap, err := loadWord2Vec(word2vec)
	if err != nil {
		return nil, fmt.Errorf("cannot load the word2vec model for the title validator: %v", err)
	}

	if verbs == "" {
		return nil, fmt.Errorf("cannot instantiate a title validator because no verb list is specified")
	}
	log.Println("Loading verb list")
	verbList, err := loadVerbs(verbs)
	if err != nil {
		return nil, fmt.Errorf("cannot load the verb list for the title validator: %v", err)
	}

	if server == "" {
		return nil, fmt.Errorf("cannot instantiate a title validator because no parser server is specified")
	}
	log.Println("Testing parser server")
	parserClient := &ParserClient{
		server: server,
	}
	_, err = parserClient.Parse("this is a test string")
	if err != nil {
		return nil, fmt.Errorf("parser server does not function correctly: %v", err)
	}
	validator := &TitleValidator{
		word2vecMap:  word2vecMap,
		verbList:     verbList,
		parserClient: parserClient,
	}
	validator.addRules(defaultRuleSet)
	return validator, nil
}

func (validator *TitleValidator) addRules(mask ruleType) {
	// Add the rules that the validator checks
	for bit, r := range ruleMap {
		if mask&bit > 0 {
			validator.rules = append(validator.rules, r)
		}
	}
	if mask&hasSemanticCousinsRule > 0 {
		validator.rules = append(validator.rules, validator.hasSemanticCousins)
	}
	log.Println("added", len(validator.rules))
}

func (validator *TitleValidator) hasSemanticCousins(parsedTitle *parsedTitle) ([]*TitleViolation, error) {
	return findSemanticCousins(parsedTitle, validator.word2vecMap, validator.verbList)
}

// Validate prepares the data that is needed for running the title linter and calls the function
// that checks the rules.
func (validator *TitleValidator) Validate(title, code, prelude string) ([]*TitleViolation, error) {
	// Preprocess title
	parsableTitle, cleanTitle := preprocessTitle(title)

	// Generate parse tree for the title
	parseTree, err := validator.parserClient.Parse(title)
	if err != nil {
		return nil, fmt.Errorf("error communicating with parser backend: %v", err)
	}

	// Get the pos tag for each word token in the title.
	tags := parseTags(parseTree)

	parsedTitle := parsedTitle{
		parsableTitle: parsableTitle,
		cleanTitle:    cleanTitle,
		parseTree:     parseTree,
		tags:          tags,
		code:          code,
		prelude:       prelude,
	}

	return validator.checkRules(&parsedTitle)
}

// checkRules goes through each of the rules and returns a list of violations if exists.
func (validator *TitleValidator) checkRules(parsedTitle *parsedTitle) ([]*TitleViolation, error) {
	var violations []*TitleViolation
	var errors []error

	for _, rule := range validator.rules {
		v, e := rule(parsedTitle)
		violations = append(violations, v...)
		errors = append(errors, e)
	}

	// Merge the error messages
	var err error
	for _, e := range errors {
		if e == nil {
			continue
		}
		if err == nil {
			err = e
		} else {
			err = fmt.Errorf("%s", strings.Join([]string{e.Error(), err.Error()}, "\n"))
		}
	}
	return violations, err
}

// token represents a word token and its part-of-speech (pos) tag
type token struct {
	partofspeech string
	text         string
}

// word2vec is a struct that we use to load in a pre-trained word2vec model.
type word2vec struct {
	Word string    `json:"word"`
	Vec  []float64 `json:"vec"`
}

// arg is a data structure that we use to store function arguments.
type arg struct {
	key string
	val string
}

// strList allows us to define functions that operate on []string.
// The functinos that operate on string lists are defined in titlestyle.go.
type strList []string

// findAny checks if any of the words in ws is in sl.
func (sl strList) findAny(ws []string) bool {
	for _, w := range ws {
		if sl.find(w) {
			return true
		}
	}
	return false
}

// find checks if w is in sl.
func (sl strList) find(w string) bool {
	for _, s := range sl {
		if w == s {
			return true
		}
	}
	return false
}

// loadVerbs load a list of preferred verbs
func loadVerbs(f string) (strList, error) {
	verblist := make(strList, 0)
	in, err := fileutil.NewReader(f)
	if err != nil {
		return nil, err
	}
	defer in.Close()

	scanner := bufio.NewScanner(in)
	for scanner.Scan() {
		verblist = append(verblist, scanner.Text())
	}
	return verblist, nil
}

// load 300K pre-trained word2vec pairs (these are obtained from google's
// word2vec model, which is trained on 3B of words.)
func loadWord2Vec(fname string) (map[string][]float64, error) {
	word2vecMap := make(map[string][]float64)
	in, err := awsutil.NewCachedS3Reader(fname)
	if err != nil {
		return nil, err
	}
	defer in.Close()

	decomp, err := gzip.NewReader(in)
	if err != nil {
		return nil, err
	}
	defer decomp.Close()

	decoder := json.NewDecoder(decomp)
	for {
		var v word2vec
		err = decoder.Decode(&v)
		if err == io.EOF {
			break
		}
		word2vecMap[v.Word] = v.Vec
	}
	return word2vecMap, nil
}

// these data structs are used to read the parse response from the server
type response struct {
	Result string
}

type result struct {
	Sentences []sentence
}

type sentence struct {
	Parsetree string
}

// parseQuery is a struct that wraps the parse query
type parseQuery struct {
	Method  string   `json:"method"`
	Params  []string `json:"params"`
	ID      int      `json:"id"`
	Version string   `json:"jsonrpc"`
}

// ParserClient wraps the process of making a query to the parser server.
type ParserClient struct {
	server string
}

// Parse makes an http request to a remote web server that hosts the parser
// and return the parse results.
func (c *ParserClient) Parse(title string) (string, error) {
	query := parseQuery{
		Method:  "parse",
		Params:  []string{title},
		ID:      2020,
		Version: "2.0",
	}

	b, err := json.Marshal(query)
	if err != nil {
		return "", err
	}

	req, err := http.NewRequest("POST", c.server, bytes.NewBuffer(b))
	if err != nil {
		return "", nil
	}
	req.Header.Set("content-type", "application/json")

	client := &http.Client{}
	resp, err := client.Do(req)
	if err != nil {
		return "", err
	}

	defer resp.Body.Close()
	contents, err := ioutil.ReadAll(resp.Body)
	if err != nil {
		return "", err
	}

	var pt response
	err = json.Unmarshal(contents, &pt)
	if err != nil {
		return "", err
	}

	var res result
	err = json.Unmarshal([]byte(pt.Result), &res)
	if err != nil {
		return "", err
	}

	var parsetrees []string
	for _, s := range res.Sentences {
		parsetrees = append(parsetrees, contentInSquares.ReplaceAllString(s.Parsetree, ""))
	}
	return strings.Join(parsetrees, " "), nil
}
