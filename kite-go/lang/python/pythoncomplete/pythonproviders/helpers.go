package pythonproviders

import (
	"fmt"
	"strings"
	"sync"

	"github.com/kiteco/kiteco/kite-go/lang/python/pythonmodels/callprobcallmodel"

	"github.com/kiteco/kiteco/kite-go/lang/editorapi"
	"github.com/kiteco/kiteco/kite-go/lang/python/pythonast"
	"github.com/kiteco/kiteco/kite-go/lang/python/pythoncode"
	"github.com/kiteco/kiteco/kite-go/lang/python/pythongraph"
	"github.com/kiteco/kiteco/kite-go/lang/python/pythonimports"
	"github.com/kiteco/kiteco/kite-go/lang/python/pythonlocal"
	"github.com/kiteco/kiteco/kite-go/lang/python/pythonmodels/callprob"
	"github.com/kiteco/kiteco/kite-go/lang/python/pythonresource"
	"github.com/kiteco/kiteco/kite-go/lang/python/pythontype"
	"github.com/kiteco/kiteco/kite-go/response"
	"github.com/kiteco/kiteco/kite-golib/complete/data"
	"github.com/kiteco/kiteco/kite-golib/errors"
	"github.com/kiteco/kiteco/kite-golib/kitectx"
	"github.com/kiteco/kiteco/kite-golib/rollbar"
)

var (
	useGGNNCompletions     = false
	useGGNNCompletionsLock sync.Mutex
)

// SetUseGGNNCompletions is a hack to allow test clients to enable ggnn completions
func SetUseGGNNCompletions(val bool) {
	useGGNNCompletionsLock.Lock()
	defer useGGNNCompletionsLock.Unlock()
	useGGNNCompletions = val
}

func ggnnCompletionsEnabled() bool {
	useGGNNCompletionsLock.Lock()
	defer useGGNNCompletionsLock.Unlock()
	return useGGNNCompletions
}

const (
	maxCallPatternsForAttrCompletions = 2
	alwaysUsePopularityForAttrs       = true
	mungeBufferForAttrs               = true
	maxResultsPerCallPattern          = 2
)

func mightBeKind(ctx kitectx.Context, val pythontype.Value, kinds ...pythontype.Kind) bool {
	for _, val := range pythontype.Disjuncts(ctx, val) {
		actual := val.Kind()
		for _, expected := range kinds {
			if actual == expected {
				return true
			}
		}
	}
	return false
}

func mostFreqType(ats map[pythonimports.Hash]pythonresource.SigStatTypeInfo) string {
	var t string
	var count int
	for _, typeInfo := range ats {
		if typeInfo.Count > count || (typeInfo.Count == count && t < typeInfo.Path) {
			count = typeInfo.Count
			t = typeInfo.Path
		}
	}
	ts := strings.Split(t, ".")
	return ts[len(ts)-1]
}

func findApplicableNode(underSelection []pythonast.Node, in Inputs) (pythonast.Expr, error) {
	for _, n := range underSelection {
		switch n := n.(type) {
		case *pythonast.ImportNameStmt:
			return nil, data.ProviderNotApplicableError{}
		case *pythonast.ImportFromStmt:
			return nil, data.ProviderNotApplicableError{}
		case *pythonast.ClassDefStmt:
			// don't complete if the selection overlaps the name of a class def
			if in.Selection.End > int(n.Class.End) && in.Selection.Begin <= int(n.Name.End()) {
				return nil, data.ProviderNotApplicableError{}
			}
		case *pythonast.FunctionDefStmt:
			// don't complete if the selection overlaps the name of a function def
			if in.Selection.End > int(n.Def.End) && in.Selection.Begin <= int(n.Name.End()) {
				return nil, data.ProviderNotApplicableError{}
			}
		case *pythonast.Parameter:
			// don't complete if the selection overlaps the argument name of a function def or lambda
			if in.Selection.Begin <= int(n.Name.End()) {
				return nil, data.ProviderNotApplicableError{}
			}
		case *pythonast.Argument:
			// If we see a function argument and the selection overlaps the kwargs part of the function call
			// (but not kwarg value), don't match
			if argumentIsKwarg(n, underSelection) {
				if pythonast.IsNil(n.Name) {
					return nil, data.ProviderNotApplicableError{}
				}
				if in.Selection.Begin <= int(n.Name.End()) {
					return nil, data.ProviderNotApplicableError{}
				}
			}
		case *pythonast.NameExpr:
			// don't trigger if the selection is before a NameExpr
			if in.Selection.End > int(n.Begin()) {
				return n, nil
			}
		case *pythonast.BadExpr:
			// Don't trigger directly on a BadExpr (in the following case).
			// Only trigger on *descendents* of BadExprs.
		case pythonast.Expr:
			if !pythonast.IsNil(n) && in.Selection.Begin == int(n.Begin()) && in.Selection.End == int(n.End()) {
				return n, nil
			}
		}
	}
	return nil, nil
}

// This function is a helper function to render placeholder generated by the GGNN model based on the signature pattern data
func renderPlaceholder(name string, index int, sigStats *pythonresource.SigStats) (string, bool) {
	if sigStats == nil {
		return data.HoleWithPlaceholderMarks("..."), false
	}

	if name != "" {
		argStat, ok := sigStats.ArgsByName[name]
		if !ok {
			return data.HoleWithPlaceholderMarks("..."), false
		}
		specType := mostFreqType(argStat.Types)
		if specType != "" {
			return data.HoleWithPlaceholderMarks(specType), false
		}
		return data.HoleWithPlaceholderMarks("..."), false
	}
	if index >= len(sigStats.Positional) {
		return data.HoleWithPlaceholderMarks("..."), true
	}
	argStat := sigStats.Positional[index]
	if argStat.Name != "" {
		return data.HoleWithPlaceholderMarks(argStat.Name), false
	}
	specType := mostFreqType(argStat.Types)
	if specType != "" {
		return data.HoleWithPlaceholderMarks(specType), false
	}
	return data.HoleWithPlaceholderMarks("..."), false

}

func argsForCall(args []pythongraph.PredictedCallArg, sigStats *pythonresource.SigStats, numOrigArgs int) string {
	var parts []string
	for i, arg := range args {
		if arg.Stop {
			break
		}
		i += numOrigArgs
		if arg.Name != "" {
			argVal := arg.Value
			if arg.Value == pythongraph.PlaceholderPlaceholder {
				if sigStats == nil {
					parts = append(parts, fmt.Sprintf("%v=%v", arg.Name, data.HoleWithPlaceholderMarks("...")))
					continue
				}
				// check if the name is in argSpec
				argStat, ok := sigStats.ArgsByName[arg.Name]
				if !ok {
					parts = append(parts, fmt.Sprintf("%v=%v", arg.Name, data.HoleWithPlaceholderMarks("...")))
					continue
				}

				specType := mostFreqType(argStat.Types)
				if specType != "" {
					argVal = data.HoleWithPlaceholderMarks(specType)
				} else {
					argVal = data.HoleWithPlaceholderMarks("...")
				}
				parts = append(parts, fmt.Sprintf("%v=%v", arg.Name, argVal))
				continue
			}
			parts = append(parts, fmt.Sprintf("%v=%v", arg.Name, data.Hole(argVal)))
			continue
		}
		if arg.Value == pythongraph.PlaceholderPlaceholder {
			if sigStats == nil {
				parts = append(parts, data.HoleWithPlaceholderMarks("..."))
				continue
			}
			// check if the completed argument is a varg.
			if i >= len(sigStats.Positional) {
				parts = append(parts, data.HoleWithPlaceholderMarks("..."))
				continue
			}

			argStat := sigStats.Positional[i]
			if argStat.Name != "" {
				parts = append(parts, data.HoleWithPlaceholderMarks(argStat.Name))
				continue
			}
			// get most frequent type
			specType := mostFreqType(argStat.Types)
			if specType != "" {
				parts = append(parts, data.HoleWithPlaceholderMarks(specType))
				continue
			}
			parts = append(parts, data.HoleWithPlaceholderMarks("..."))
		} else {
			parts = append(parts, data.Hole(arg.Value))
		}
	}
	return strings.Join(parts, ", ")
}

// function to count the number of argument in the call
func numCallArgs(args []pythongraph.PredictedCallArg) int {
	var numArgs int
	for _, arg := range args {
		if arg.Stop {
			break
		}
		numArgs++
	}
	return numArgs
}

// function to compute callprob confidence score in batch
func computeCallScoreBatch(ctx kitectx.Context, model *callprob.Model, predictions pythongraph.PredictedCallSummary, in callprob.Inputs) []float32 {
	ctx.CheckAbort()

	// return early to avoid rollbar
	if len(predictions.Predicted) == 0 {
		return nil
	}

	in.Sym = predictions.Symbol
	in.CallComps = predictions.Predicted
	probs, err := model.Infer(ctx, in)
	if len(probs) > 0 {
		return probs
	}

	switch err.(type) {
	case callprob.NoSymbolInTableError, callprob.NoSigStatsError, callprob.NoArgSpecsError, callprob.NoExprError:
	default:
		rollbar.Error(errors.Wrapf(err, "failed to run call prob model"))
	}

	return nil
}

// function to compute callprob confidence score in batch
func computeCallScoreBatchForCallModel(ctx kitectx.Context, model *callprobcallmodel.Model, predictions pythongraph.PredictedCallSummary, in callprobcallmodel.Inputs) []float32 {
	ctx.CheckAbort()
	// return early to avoid rollbar
	if len(predictions.Predicted) == 0 {
		return nil
	}
	in.Sym = predictions.Symbol
	in.CallComps = predictions.Predicted
	probs, err := model.Infer(ctx, in)
	if len(probs) > 0 {
		return probs
	}

	switch err.(type) {
	case callprobcallmodel.NoSymbolInTableError, callprobcallmodel.NoSigStatsError, callprobcallmodel.NoArgSpecsError, callprobcallmodel.NoExprError:
	default:
		rollbar.Error(errors.Wrapf(err, "failed to run call prob model"))
	}
	return nil
}

func holeForPlaceholderTypes(ts []string) string {
	var elems []string
	for _, t := range ts {
		if len(elems) == maxTypesForPlaceholder {
			break
		}
		if t != "" {
			elems = append(elems, pythonimports.NewDottedPath(t).Last())
		}
	}
	if len(elems) == 0 {
		elems = append(elems, "...")
	}
	return data.HoleWithPlaceholderMarks(strings.Join(elems, "|"))
}

// find the deepest node under the position, that is not entirely contained within the position:
// so in foo(‸bar()‸), call expr bar() is not chosen, but rather the outer call expr.
func deepestNotContained(underPos []pythonast.Node, s data.Selection) pythonast.Node {
	var n pythonast.Node
	for i := len(underPos) - 1; i >= 0; i-- {
		n = underPos[i]
		if s.Begin == int(n.Begin()) && s.End == int(n.End()) {
			continue
		}
		break
	}
	return n
}

type funcInfo struct {
	Source response.EditorCompletionSource

	Val pythontype.Value

	// all the below may be nil
	Sigs     []*editorapi.Signature
	Spec     *pythonimports.ArgSpec
	Kwargs   *pythonresource.KeywordArgs // only set for global functions
	Patterns *pythoncode.MethodPatterns  // only set for local functions
	Symbol   pythonresource.Symbol       // only set for global functions
}

func funcInfos(ctx kitectx.Context, rm pythonresource.Manager, idx *pythonlocal.SymbolIndex, val pythontype.Value) []funcInfo {
	ctx.CheckAbort()

	val = pythontype.Translate(ctx, val, rm)
	var allPatterns []funcInfo
	for _, val := range pythontype.Disjuncts(ctx, val) {
		switch val := val.(type) {
		case pythontype.ConstantValue:
			if ext, ok := pythontype.WidenConstant(val, rm).(pythontype.External); ok {
				sigs := rm.PopularSignatures(ext.Symbol())
				spec := rm.ArgSpec(ext.Symbol())
				allPatterns = append(allPatterns, funcInfo{
					Sigs:   sigs,
					Val:    ext,
					Spec:   spec,
					Kwargs: rm.Kwargs(ext.Symbol()),
					Symbol: ext.Symbol(),
					Source: response.GlobalPopularPatternCompletionSource,
				})
			}
		case pythontype.GlobalValue:
			if ext, ok := val.(pythontype.External); ok {
				sigs := rm.PopularSignatures(ext.Symbol())
				spec := rm.ArgSpec(ext.Symbol())
				allPatterns = append(allPatterns, funcInfo{
					Sigs:   sigs,
					Val:    ext,
					Spec:   spec,
					Kwargs: rm.Kwargs(ext.Symbol()),
					Symbol: ext.Symbol(),
					Source: response.GlobalPopularPatternCompletionSource,
				})
			}
		case pythontype.SourceValue:
			if idx != nil {
				spec, _ := idx.ArgSpec(ctx, val)
				pats, _ := idx.MethodPatterns(ctx, val)
				var sigs []*editorapi.Signature
				if pats != nil {
					sigs = pythoncode.EditorSignatures(pats)
				}

				allPatterns = append(allPatterns, funcInfo{
					Sigs:     sigs,
					Val:      val,
					Spec:     spec,
					Patterns: pats,
					Source:   response.LocalPopularPatternCompletionSource,
				})
			}
		default:
			panic("unhandled value type")
		}
	}
	return allPatterns
}

func argumentIsKwarg(argument *pythonast.Argument, underCursor []pythonast.Node) bool {
	if argument.Equals != nil {
		return true
	}
	// Find the CallExpr that is the parent of the argument.
	var callExpr *pythonast.CallExpr
	for i, node := range underCursor {
		if node == argument && i > 0 {
			switch n := underCursor[i-1].(type) {
			case *pythonast.CallExpr:
				callExpr = n
			}
		}
	}
	if callExpr == nil {
		return false
	}

	// See if there is a keyword argument before the current argument
	for _, arg := range callExpr.Args {
		if arg == argument {
			break
		}
		if arg.Equals != nil {
			return true
		}
	}

	return false
}
