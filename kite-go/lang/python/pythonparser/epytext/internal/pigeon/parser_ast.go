package pigeon

import (
	"fmt"

	"github.com/kiteco/kiteco/kite-go/lang/python/pythonparser/epytext/ast"
)

// NOTE: this is the "AST" (actually a flat list of blocks) generated by the
// pigeon parser. This AST is then post-processed in the pigeon parser's
// top-level action (grammarAction) to construct the actual hierarchical
// AST returned to the caller.

// converts a flat list of (internal) blocks to the exported
// hierarchical AST format.
func toHierarchicalAST(blocks []block) *ast.DocBlock {
	if len(blocks) == 0 {
		return nil
	}

	// helper function to merge inline paragraphs in lists and fields with
	// a subsequent paragraph.
	mergeWithNextParagraph := func(current block, index int, canMerge, litIntro bool, inlineP string) paragraph {
		// if there is an inline paragraph for this block and it can
		// be merged with a subsequent paragraph...
		if canMerge && index+1 < len(blocks) {
			next := blocks[index+1]
			// merge it if the next block is a paragraph that is a child
			// of the current block.
			if p, ok := next.(paragraph); ok && current.parentOf(p) {
				blocks[index+1] = makeParagraph(p.i, inlineP+"\n"+p.t, p.litIntro)
				return paragraph{} // no additional paragraph created
			}
		}
		if inlineP != "" {
			// if the current block has an inline paragraph but could not
			// be merged, return an additional paragraph.
			return makeParagraph(current.indent(), inlineP, litIntro)
		}
		return paragraph{}
	}

	// first, process the flat blocks and generate the new paragraphs
	// for inline paragraphs inside lists and fields (or merge the
	// inline paragraphs in the following one).
	finalBlocks := make([]block, 0, len(blocks))
	for i, b := range blocks {
		var addedP paragraph

		switch b := b.(type) {
		case list:
			addedP = mergeWithNextParagraph(b, i, b.mergeP, b.litIntro, b.inlineP)

		case field:
			addedP = mergeWithNextParagraph(b, i, b.mergeP, b.litIntro, b.inlineP)
		}

		finalBlocks = append(finalBlocks, b)
		if addedP.t != "" {
			finalBlocks = append(finalBlocks, addedP)
		}
	}

	// then process the flat list of blocks and generate hierarchical AST nodes,
	// processing inline markup in the process.
	head, lastIndex := buildTree(doc{}, finalBlocks, 0)
	if lastIndex != len(finalBlocks) {
		panic(fmt.Sprintf("lastIndex: %d, len(finalBlocks): %d", lastIndex, len(finalBlocks)))
	}
	doc, ok := head.(*ast.DocBlock)
	if !ok {
		panic(fmt.Sprintf("head AST block is not *ast.DocBlock: %T", head))
	}
	return doc
}

func buildTree(parent block, blocks []block, startIndex int) (head ast.Node, nextIndex int) {
	astb := parent.toAST()
	for i := startIndex; i < len(blocks); i++ {
		b := blocks[i]

		if parent.parentOf(b) {
			// if parent can contain b, then parent's AST Block must be
			// a NestingNode, otherwise panic.
			nn, ok := astb.(ast.NestingNode)
			if !ok {
				panic(fmt.Sprintf("block is parent but AST node is not a nesting node: %T", astb))
			}

			child, nextIndex := buildTree(b, blocks, i+1)
			appendNodes(nn, child)
			i = nextIndex - 1 // to account for i++
			continue
		}

		// otherwise b is a sibling of parent, unwind the recursive call stack
		return astb, i
	}
	return astb, len(blocks)
}

func appendNodes(parent ast.NestingNode, children ...ast.Node) {
	switch parent := parent.(type) {
	case *ast.BasicMarkup:
		parent.Nodes = append(parent.Nodes, children...)
	case *ast.URLMarkup:
		parent.Nodes = append(parent.Nodes, children...)
	case *ast.CrossRefMarkup:
		parent.Nodes = append(parent.Nodes, children...)
	case *ast.DocBlock:
		parent.Nodes = append(parent.Nodes, children...)
	case *ast.SectionBlock:
		parent.Nodes = append(parent.Nodes, children...)
	case *ast.ParagraphBlock:
		parent.Nodes = append(parent.Nodes, children...)
	case *ast.ListBlock:
		parent.Nodes = append(parent.Nodes, children...)
	case *ast.FieldBlock:
		parent.Nodes = append(parent.Nodes, children...)
	default:
		panic(fmt.Sprintf("unknown node type: %T", parent))
	}
}

type block interface {
	indent() int
	text() string
	parentOf(block) bool
	toAST() ast.Node
}

// doc is a special block type that is the parent of all other
// blocks.
type doc struct{}

func (d doc) indent() int           { return -1 }
func (d doc) text() string          { return "" }
func (d doc) parentOf(b block) bool { return true }
func (d doc) toAST() ast.Node       { return &ast.DocBlock{} }

type fieldTag struct {
	name string
	arg  string
}

type common struct {
	i int
	t string
}

func (c common) indent() int  { return c.i }
func (c common) text() string { return c.t }

func makeCommon(i int, t string) common {
	return common{i: i, t: t}
}

type plainText struct {
	common
}

func makePlainText(i int, t string) plainText {
	return plainText{common: makeCommon(i, t)}
}

type section struct {
	common
	level byte // '=', '-' or '~'
}

func (s section) parentOf(b block) bool {
	// Chilren's indentation is >= to that of the section, except if it is a
	// section.
	switch b.(type) {
	case section:
		return b.indent() > s.indent()
	case paragraph, list, literal, doctest:
		return b.indent() >= s.indent()
	default:
		// cannot contain field
		return false
	}
}

func (s section) toAST() ast.Node {
	return &ast.SectionBlock{
		Header: ast.Header(s.level),
		Nodes:  parseText(s.t),
	}
}

func makeSection(i int, t string, level byte) section {
	return section{common: makeCommon(i, t), level: level}
}

type paragraph struct {
	common
	litIntro bool // true if paragraph introduces a Literal (::)
}

func (p paragraph) parentOf(b block) bool {
	// Children's indentation is > to that of the paragraph, equal indent
	// is a sibling, except for literals which have the same indent as
	// the paragraph that introduces them.
	switch b.(type) {
	case paragraph, doctest, list:
		return b.indent() > p.indent()
	case literal:
		return b.indent() >= p.indent()
	default:
		// cannot contain field and section
		return false
	}
}

func (p paragraph) toAST() ast.Node {
	return &ast.ParagraphBlock{
		Nodes: parseText(p.t),
	}
}

func makeParagraph(i int, t string, lit bool) paragraph {
	return paragraph{common: makeCommon(i, t), litIntro: lit}
}

type list struct {
	common
	inlineP  string
	mergeP   bool // true if inlineP can be merged with a subsequent paragraph
	litIntro bool // true if inlineP introduces a Literal (::)
}

func (l list) parentOf(b block) bool {
	// Chilren's indentation is >= to that of the list, except for lists
	// that must be >.
	switch b.(type) {
	case paragraph, literal, doctest:
		return b.indent() >= l.indent()
	case list:
		return b.indent() > l.indent()
	default:
		// cannot contain section and field
		return false
	}
}

func (l list) toAST() ast.Node {
	typ := ast.UnorderedList
	if l.t != "-" {
		typ = ast.OrderedList
	}
	return &ast.ListBlock{
		Bullet:   l.t,
		ListType: typ,
	}
}

func makeList(i int, t string, inlineP string, mergeP, lit bool) list {
	return list{common: makeCommon(i, t), inlineP: inlineP, mergeP: mergeP, litIntro: lit}
}

type field struct {
	common
	arg      string
	inlineP  string
	mergeP   bool // true if inlineP can be merged with a subsequent paragraph
	litIntro bool // true if inlineP introduces a Literal (::)
}

func (f field) parentOf(b block) bool {
	// Chilren's indentation is >= to that of the list, except for lists, fields
	// and sections, that must be >.
	switch b.(type) {
	case paragraph, list, literal, doctest:
		return b.indent() >= f.indent()
	default:
		// cannot contain section and field
		return false
	}
}

func (f field) toAST() ast.Node {
	return &ast.FieldBlock{
		Name: f.t,
		Arg:  f.arg,
	}
}

func makeField(i int, t string, arg, inlineP string, mergeP, lit bool) field {
	return field{common: makeCommon(i, t), arg: arg, inlineP: inlineP, mergeP: mergeP, litIntro: lit}
}

type doctest struct {
	common
}

func (d doctest) parentOf(b block) bool {
	// cannot have nested blocks
	return false
}

func (d doctest) toAST() ast.Node {
	return &ast.DoctestBlock{RawText: d.t}
}

func makeDoctest(i int, t string) doctest {
	return doctest{common: makeCommon(i, t)}
}

type literal struct {
	common
}

func (l literal) parentOf(b block) bool {
	// cannot have nested blocks
	return false
}

func (l literal) toAST() ast.Node {
	return &ast.LiteralBlock{RawText: l.t}
}

func makeLiteral(i int, t string) literal {
	return literal{common: makeCommon(i, t)}
}
