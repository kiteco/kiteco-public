package filter

import (
	"path"
	"path/filepath"
	"strings"

	"github.com/kiteco/kiteco/kite-go/lang"
	"github.com/kiteco/kiteco/kite-golib/complete/data"
	"github.com/kiteco/kiteco/kite-golib/lexicalv0"
	"github.com/kiteco/kiteco/kite-golib/lexicalv0/text"
)

// File returns true if the filename/buffer provided should
// be filtered from source code datasets. This includes vocab generation and training
// NOTE: `fn` should be a slash separated path.
func File(fn string, buf []byte) bool {
	// Language agnostic filters

	// Protocol buffer files (.pb.*), min.js, etc
	if strings.Count(path.Base(fn), ".") > 1 {
		return true
	}

	// Node modules (may appear with variety of language extensions)
	if strings.Contains(fn, "/node_modules/") {
		return true
	}

	fileLang := lang.FromFilename(filepath.FromSlash(fn))
	switch fileLang {
	case lang.Golang:
		if filepath.Base(fn) == "bindata.go" {
			return true
		}
		if strings.Contains(fn, "/vendor/") || strings.Contains(fn, "/Godeps/") {
			return true
		}
	}

	if !lexicalv0.AllLangsGroup.Contains(fileLang) {
		return false
	}

	// Generated by -- doing this last as its a bit more expensive
	bufstr := strings.ToLower(string(buf))
	pos := strings.Index(bufstr, "generated by")
	if pos != -1 {
		sb := data.NewBuffer(bufstr).Select(data.Selection{Begin: pos, End: pos})
		if text.CursorInComment(sb, fileLang) {
			return true
		}
	}

	return false
}
