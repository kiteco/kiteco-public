package data

import (
	"encoding/json"

	"github.com/kiteco/kiteco/kite-golib/errors"
	"github.com/kiteco/kiteco/kite-golib/stringindex"
)

// Editor indicated the client of the API, used to choose options
type Editor string

// All the Editors
const (
	SpyderEditor   Editor = "spyder"
	IntelliJEditor Editor = "intellij"
	SublimeEditor  Editor = "sublime3"
	VSCodeEditor   Editor = "vscode"
	VimEditor      Editor = "vim"
	AtomEditor     Editor = "atom"
	JupyterEditor  Editor = "jupyter"
)

// String implements fmt.Stringer
func (e Editor) String() string {
	return string(e)
}

// UMF encapsulates a user ID, machine ID, and file name
type UMF struct {
	UserID    int64  `json:"user_id"`
	MachineID string `json:"machine_id"`
	Filename  string `json:"filename"`
}

// APIOptions encapsulates API-exposed options.
type APIOptions struct {
	Editor     Editor `json:"editor"`
	NoSnippets bool   `json:"no_snippets"`
	NoUnicode  bool   `json:"no_unicode"`

	// Encoding is the requested offset encoding
	Encoding stringindex.OffsetEncoding `json:"offset_encoding"`
}

// APIRequest encapsulates API request data
type APIRequest apiRequest
type apiRequest struct {
	UMF
	APIOptions
	SelectedBuffer

	// curEncoding is the current in-memory offset encoding.
	curEncoding stringindex.OffsetEncoding
}

// UnmarshalJSON implements JSONUnmarshaler
func (r *APIRequest) UnmarshalJSON(b []byte) error {
	if err := json.Unmarshal(b, (*apiRequest)(r)); err != nil {
		return errors.Wrapf(err, "error unmarshaling request")
	}

	var deprecated = struct {
		Position *Selection `json:"position"`
	}{}
	if err := json.Unmarshal(b, &deprecated); err == nil {
		if deprecated.Position != nil {
			r.Selection = *deprecated.Position
		}
	}

	r.curEncoding = r.APIOptions.Encoding

	return r.Validate()
}

// Validate checks that the request is valid, and "canonicalizes" it.
func (r *APIRequest) Validate() error {
	if r.Selection.End < r.Selection.Begin {
		return errors.Errorf("invalid selection")
	}
	return errors.WrapfOrNil(r.EncodeOffsets(stringindex.Native), "error decoding offsets")
}

// EncodeOffsets encodes the selection offsets with the given encoding.
func (r *APIRequest) EncodeOffsets(enc stringindex.OffsetEncoding) error {
	// Re-encode even if r.curEncoding == encode
	// in order to check that the offsets are properly aligned,
	// since this data came from the outside.
	if err := r.SelectedBuffer.EncodeOffsets(r.curEncoding, enc); err != nil {
		return err
	}
	r.curEncoding = enc
	return nil
}

// EngineMetricsCallback is a callback for the completions engine that records metrics generated by a completion request.
type EngineMetricsCallback func(acceptedProviders map[ProviderName]struct{}, fulfillingProviders map[ProviderName]struct{})

// APIResponse encapsulates an API response.
type APIResponse apiResponse
type apiResponse struct {
	// json tags are only used for unmarshaling.
	Request APIRequest `json:"-"`

	// Error and HTTPStatus are not included in encoded JSON.
	Error      string `json:"error,omitempty"`
	HTTPStatus int    `json:"http_status"`

	// Encoding is the current in-memory offset encoding.
	Encoding    stringindex.OffsetEncoding `json:"offset_encoding"`
	Completions []NRCompletion             `json:"completions"`
}

// NewAPIResponse creates a new empty APIResponse for a given APIRequest.
func NewAPIResponse(req APIRequest) APIResponse {
	return APIResponse{
		Request:    req,
		HTTPStatus: 200,
		Encoding:   stringindex.Native,
	}
}

// MarshalJSON implements json.Marshaler
func (r APIResponse) MarshalJSON() ([]byte, error) {
	if err := r.EncodeOffsets(r.Request.APIOptions.Encoding); err != nil {
		return nil, err
	}
	return json.Marshal(apiResponse(r))
}

// EncodeOffsets encodes the completion offsets with the given encoding.
// Requires that a Request be set (use NewAPIResponse).
func (r *APIResponse) EncodeOffsets(enc stringindex.OffsetEncoding) error {
	// Don't re-encode if r.Encoding == enc since it consumes memory,
	// and we can trust that the internal offsets were computed correctly.
	if r.Encoding == enc {
		return nil
	}
	comps := make([]NRCompletion, 0, len(r.Completions))
	for _, c := range r.Completions {
		if err := c.EncodeOffsets(r.Request.SelectedBuffer.Text(), r.Encoding, enc); err != nil {
			return err
		}
		comps = append(comps, c)
	}
	r.Completions = comps
	r.Encoding = enc
	return nil
}

// ToError returns an error if there's an Error
func (r APIResponse) ToError() error {
	if r.Error == "" {
		return nil
	}
	return errors.New(r.Error)
}
